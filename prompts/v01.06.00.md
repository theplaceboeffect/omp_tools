# v01.06.00
 - Generate testing framework for the script.
Generate a testing framework for the script. There many combinations of OSes, shells, and runtime environments that need to be tested.

Do not execute any tests - this prompt is about generating a framework and tools for how to test the script.

1. Review the original scripts omp_toosl.ps1 and omp_tools.zsh to understand the functionality.
1. Create a testing framework for the script.
1. Positive Test every function:
    - Test launching the script with no arguments.
    - Once the script has been sourced into the appropriate shell, run every function.
    - Do not write tests for interactive applications.
1. Negative test the script:
    - Test the script with invalid arguments.
    - Run the scripts in different shells.
1. Generate the following file hierarchy:
    - bin/ - will contain all common libraries and tools for testing.
    - <branch name>/ - will contain all the data for the test runs for this branch.
    - <branch name>/bin - will contain the specific test scripts for each test.
    - <branch name>/test/OS-Shell - will contain the test artifacts for each test.
1. Generate the testing scripts.
    - Generate the scripts using PowerShell (this is probably a better language than ZSH)
    - Generate a test_init.ps1 script that will initialize the test directory for each branch.
    - Do not change any files outside of the test directory.
    - Simulate changes to the home directory using files prefixed with HOME-xxx.

## Implementation Hints

## QOL requirements

- if the branch name isn't specified look it up via git commands.

## PowerShell Scripting
- Forbidden Words: Honor PowerShell conventions, don't use known parameter names such as Verbose.
- Avoid relative paths "../xx", prefer full paths relative to the test root directory. 
    - Store the test root "tests/" root path in all-tests.
    - Test scripts should be run from the test_root and fail otherwise.

### Testing Framework Architecture
- **Isolation**: Use PowerShell sessions or mock objects to isolate test environments
- **Cross-platform compatibility**: Handle different OS path separators and shell environments
- **Mock dependencies**: Mock oh-my-posh commands to avoid external dependencies
- **Error handling**: Gracefully handle missing files, invalid inputs, and permission issues

### Key Technical Considerations
- **WSMan limitations**: On macOS, PowerShell sessions may not work due to WSMan restrictions. Use mock objects instead
- **Path resolution**: Test scripts run from branch directories, so relative paths need careful handling
- **Parameter conflicts**: Avoid using `-Verbose` parameter name (PowerShell built-in). Use `-ShowVerbose` instead
- **File structure**: Tests run from `tests/<branch>/bin/` but need to access scripts in `bin/` and utilities in `tests/bin/`

### Test Categories to Implement
1. **Positive Tests**: Verify all functions exist and work with valid inputs
2. **Negative Tests**: Test error handling with invalid inputs, missing files, corrupted data
3. **Cross-platform Tests**: Test compatibility across macOS/Windows/Linux and PowerShell/Zsh
4. **Script Launch Tests**: Verify scripts load correctly with no arguments

### Common Pitfalls to Avoid
- **Session management**: Mock sessions instead of real PowerShell sessions on macOS
- **Path issues**: The test creation scripts hard-code the test home directory in the test.config file.
- **Export conflicts**: Don't use `Export-ModuleMember` when sourcing scripts
- **Parameter naming**: Avoid reserved PowerShell parameter names
- **Cleanup**: Always clean up test environments in finally blocks

### Testing Utilities to Include
- **Import-OmpToolsPS1**: Load and mock PowerShell script
- **Test-FunctionExists**: Verify functions are available
- **Test-FunctionExecution**: Execute functions with validation
- **New-TestEnvironment**: Create isolated test environments
- **Mock-OhMyPosh**: Simulate oh-my-posh commands
- **Assert-TestResult**: Validate test outcomes

### Directory Structure Pattern
```
tests/
├── bin/                          # Common utilities
│   ├── test_init.ps1            # Branch initialization
│   ├── TestUtils.ps1            # Shared test functions
│   └── test_*.ps1               # Test scripts
├── <branch>/                    # Branch-specific data
│   ├── bin/                     # Branch test scripts
│   ├── test/                    # Test artifacts
│   └── test_config.json         # Configuration
└── README.md                    # Documentation
```

### Execution Flow
1. Run `test_init.ps1 -BranchName "feature"` to create branch structure
2. Navigate to `tests/<branch>/bin/`
3. Run `run_tests.ps1` to execute all tests
4. Results saved as JSON in branch directory        
        